{"name":"PyOperant","tagline":"python package for operant conditioning","body":"PyOperant is a framework to easily construct and share new operant behavior paradigms.\r\n\r\nWith PyOperant, you can write a single behavior script that works across different species, different computers, different hardware, different rewards, different modalities.\r\n\r\nOperant logic is easy.\r\n\r\n1. Present a stimulus\r\n2. Get the subject’s response\r\n3. If the response matches the stimulus, then reward the subject\r\n\r\nWriting operant protocols should be easy, but in practice...\r\n\r\nError checking, data storage, and machine-specific hardware interactions often obfuscate the simplicity of the task, limiting its flexibility and power. This limitation becomes increasingly apparent when deploying high-throughput behavioral experiment control systems, transferring subjects from a training panel to an electrophysiology panel, or simply trying to share behavioral protocols. \r\n\r\nPyOperant deals with these challenges by providing a cross-platform object-oriented framework to easily construct, conveniently share, and rapidly iterate on new operant behavior paradigms.\r\n\r\n1. Abstract physical component manipulation from low-level hardware manipulation\r\n2. Define behavioral protocols as classes which can be extended through object inheritance\r\n\r\nFurther, experimenters are able to integrate their behavioral protocols with other Python packages for online data analysis or experimental control. We currently use pyoperant in the Gentner Lab to control 36 operant panels.\r\n\r\n# Documentation\r\n\r\nPyOperant abstracts behavioral protocol logic from hardware interactions through a machine-specific configuration file. In the local.py configuration file, the experimenter defines the operant panels available for use. A Panel consists of a collection of Component objects and a set of standard methods to manipulate the Component. These Component objects are mirrors of their physical counterparts, such as a food hopper, response port, speaker, or house light.\r\n\r\nBehavioral protocols can be modifed and extended through object inheritance. The modular architecture of PyOperant also allows experimenters to integrate their behavioral protocols with other Python packages for online data analysis or experimental control.\r\n\r\nPyOperant’s hardware support currently includes PortAudio & Comedi. Future support will include NiDAQmx and Cambridge Electronic Designs.\r\n\r\nhttp://pyoperant.readthedocs.org/en/dev/index.html\r\n\r\n# Architecture\r\n## Behaviors\r\n\r\nBehaviors are Python classes which run the operant experiment. They associate the subject with the hardware panel the subject is interacting with and save experimental data appropriately. They are instantiated with various experimental parameters, such as stimulus identities and associations, block designs, and reinforcement schedules.\r\n\r\nThere are a couple of built-in behaviors: TwoAltChoice, which runs two alternative choice tasks and Lights, which simply turns the house light on and off according to a schedule. These can be inherited to change specific methods without changing the rest of the behavioral protocol.\r\n\r\n## Panels\r\n\r\nPanels are the highest level of hardware abstraction. They maintain panel components as attributes and have standard methods for resetting and testing the panel. Many Behaviors rely on specific panel components and methods to be present. \r\n\r\nPanels are defined by the experimenter locally.\r\n\r\n## Components\r\n\r\nComponents are common hardware components, such as a Hopper, a ResponsePort, a HouseLight, or an RGBLight. Many components rely on multiple hardware IO channels. For example, a Hopper requires both a solenoid (to activate the Hopper) and an IR beam detector (to check if the Hopper is raised). Calling the ‘feed’ method on a Hopper checks to make sure that the hopper is down, raises the hopper, checks to make sure the hopper raised, waits the appropriate length of time, then lowers the hopper, finally checking one more time to make sure the hopper dropped. If there is an incongruity between the status of the solenoid and the IR beam, the Hopper component raises the appropriate error, which the Behavior script can deal with appropriately.\r\n\r\n## Hardware IO Classes\r\n\r\nHawdware IO classes standardize inputs and outputs that are available for Components and Panels to use.\r\n\r\n## Hardware interfaces\r\n\r\nHardware interfaces are wrappers around hardware drivers and APIs that allow hardware IO classes to work.\r\n\r\n# Developers\r\n\r\nJustin Kiggins & Marvin Thielk\r\n\r\nGentner Lab - http://gentnerlab.ucsd.edu\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}